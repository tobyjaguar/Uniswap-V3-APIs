import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from main import app
from models.token import Token
from routes.token import get_chart_data
from services.database import get_db

# Override the get_db dependency
async def override_get_db():
    return AsyncMock(spec=AsyncSession)

app.dependency_overrides[get_db] = override_get_db


@pytest.mark.asyncio
async def test_get_chart_data():
    print("\n--- Starting test_get_chart_data ---")
    
    # Mock token
    mock_token = MagicMock(spec=Token)
    mock_token.id = 1
    mock_token.symbol = "WBTC"
    print(f"Mock token: {mock_token.symbol}, ID: {mock_token.id}")

    # Mock price data
    mock_price_data = [
        MagicMock(
            interval_timestamp=datetime.now(ZoneInfo("UTC")) - timedelta(hours=i),
            open=100.0 + i,
            close=101.0 + i,
            high=102.0 + i,
            low=99.0 + i,
            price_usd=100.5 + i
        ) for i in range(24)
    ]
    print(f"Mock price data length: {len(mock_price_data)}")
    print(f"First mock price data point: {mock_price_data[0].__dict__}")

    # Mock database queries
    async def mock_execute(*args, **kwargs):
        print(f"Mock execute called with args: {args}")
        if "Token" in str(args[0]):
            mock_result = AsyncMock()
            mock_result.scalar_one_or_none.return_value = mock_token
            return mock_result
        else:
            mock_result = AsyncMock()
            mock_result.fetchall.return_value = mock_price_data
            return mock_result

    hours = 24
    interval_hours = 1

    print(f"Requesting data for {hours} hours with {interval_hours} hour interval")

    async with AsyncClient(app=app, base_url="http://test") as ac:
        with patch('routes.token.select', MagicMock()) as mock_select:
            with patch('routes.token.text', MagicMock()) as mock_text:
                with patch.object(AsyncSession, 'execute', mock_execute):
                    response = await ac.get(f"/api/chart-data/WBTC?hours={hours}&interval_hours={interval_hours}")
                    
    print(f"Response status code: {response.status_code}")
    print(f"Response headers: {response.headers}")
    print(f"Raw response content: {response.content}")

    assert response.status_code == 200, f"Unexpected status code: {response.status_code}"
    
    try:
        data = response.json()
        print(f"Parsed JSON data: {data}")
    except Exception as e:
        print(f"Failed to parse JSON: {e}")
        print(f"Response text: {response.text}")
        raise

    assert len(data) == 5, f"Expected 5 data types, got {len(data)}"

    data_point_counts = [len(data_type) for data_type in data]
    print(f"\nData point counts: {data_point_counts}")
    print(f"Time range requested: {hours} hours")
    print(f"Interval: {interval_hours} hour(s)")

    assert len(set(data_point_counts)) == 1, f"Inconsistent number of data points across types: {data_point_counts}"

    expected_points = hours // interval_hours + 1
    actual_points = data_point_counts[0]

    print(f"Expected number of points: {expected_points}")
    print(f"Actual number of points: {actual_points}")

    assert abs(expected_points - actual_points) <= 1, f"Number of data points ({actual_points}) significantly differs from expected ({expected_points})"

    # Check data types
    for i, data_type in enumerate(data):
        print(f"Checking data type {i}")
        for j, point in enumerate(data_type):
            print(f"  Point {j}: {point}")
            assert isinstance(point[0], str), f"Timestamp is not a string: {point[0]}"
            assert isinstance(point[1], str), f"Data type is not a string: {point[1]}"
            assert isinstance(point[2], (float, type(None))), f"Value is not float or None: {point[2]}"

    print("--- Test completed successfully ---")

if __name__ == "__main__":
    pytest.main([__file__, "-s", "-v"])

    
    # assert all(isinstance(point[0], str) and isinstance(point[1], str) and isinstance(point[2], (float, type(None))) 
    #            for data_type in data for point in data_type)
        # Debug print for problematic values
    # problematic_points = [
    #     (i, j, point)
    #     for i, data_type in enumerate(data)
    #     for j, point in enumerate(data_type)
    #     if not (isinstance(point[0], str) and isinstance(point[1], str) and isinstance(point[2], (float, type(None))))
    # ]
    
    # if problematic_points:
    #     print("\nProblematic points:")
    #     for i, j, point in problematic_points:
    #         print(f"Data type {i}, Point {j}: {point}")
    #         print(f"Types: {type(point[0])}, {type(point[1])}, {type(point[2])}")
    
    # assert not problematic_points, "Found points with incorrect types"
                    

# @pytest.mark.asyncio
# async def test_get_chart_data_token_not_found():
#     async def mock_execute(*args, **kwargs):
#         mock_result = AsyncMock()
#         mock_result.scalar_one_or_none.return_value = None
#         return mock_result

#     with patch('routes.token.select', MagicMock()):
#         with patch.object(AsyncSession, 'execute', mock_execute):
#             response = client.get("/api/chart-data/INVALID?hours=24&interval_hours=1")

#     assert response.status_code == 404
#     assert response.json()['detail'] == "Token not found"